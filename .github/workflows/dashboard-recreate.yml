name: Deploy Dashboard (Recreate)

on:
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Git branch to deploy'
        required: true
        default: 'main'
        type: string

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: data-viewer-dashboard

jobs:
  recreate:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.target_branch }}

    - name: Determine branch and image tag
      id: branch-info
      run: |
        BRANCH="${{ github.event.inputs.target_branch }}"
        SHA=$(git rev-parse HEAD)

        echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
        echo "DEPLOY_BRANCH=$BRANCH" >> "$GITHUB_ENV"
        echo "IMAGE_TAG=$SHA" >> "$GITHUB_ENV"
        echo "ðŸš€ Recreate deployment from branch: $BRANCH"
        echo "ðŸ“¦ Image tag: $SHA"
        echo "âš ï¸  This run will DESTROY and recreate all infrastructure."

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Terraform Init (no imports)
      run: |
        set -euo pipefail
        cd dashboard/deploy/terraform
        terraform init

        echo "ðŸ” Checking for failed or stuck App Runner services..."
        FAILED_SERVICE=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='data-viewer-dashboard' && (Status=='CREATE_FAILED' || Status=='DELETE_FAILED')].ServiceArn" --output text)
        if [ -n "$FAILED_SERVICE" ]; then
          echo "âš ï¸  Found failed App Runner service: $FAILED_SERVICE"
          SERVICE_STATUS=$(aws apprunner describe-service --service-arn "$FAILED_SERVICE" --query "Service.Status" --output text)
          echo "   Current status: $SERVICE_STATUS"
          aws apprunner delete-service --service-arn "$FAILED_SERVICE"
          echo "â³ Waiting for service deletion to complete..."
          aws apprunner wait service-deleted --service-arn "$FAILED_SERVICE" || true
          sleep 10
          echo "âœ… Failed service deleted"
        else
          echo "âœ… No failed services found"
        fi

    - name: Cleanup old autoscaling configurations
      run: |
        set -euo pipefail
        echo "ðŸ§¹ Cleaning up existing App Runner autoscaling configuration versions..."
        SORTED_ARNS=$(aws apprunner list-auto-scaling-configurations --auto-scaling-configuration-name "dv-dashboard-autoscale" --query "AutoScalingConfigurationSummaryList | sort_by(@, &AutoScalingConfigurationRevision)[].AutoScalingConfigurationArn" --output text 2>/dev/null || echo "")
        if [ -z "$SORTED_ARNS" ]; then
          echo "âœ… No autoscaling configuration versions found"
          exit 0
        fi
        ARN_ARRAY=($SORTED_ARNS)
        KEEP_NEWEST="${ARN_ARRAY[-1]}"
        for ARN in "${ARN_ARRAY[@]}"; do
          if [ "$ARN" = "$KEEP_NEWEST" ]; then
            echo "  Keeping newest revision: $ARN"
            continue
          fi
          echo "  Deleting old revision: $ARN"
          aws apprunner delete-auto-scaling-configuration --auto-scaling-configuration-arn "$ARN" 2>/dev/null || echo "    (failed - may already be deleted)"
        done

    - name: Terraform Destroy
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      run: |
        set -euo pipefail
        cd dashboard/deploy/terraform
        echo "âš ï¸  Destroying existing infrastructure..."
        terraform destroy -auto-approve -var="aws_region=${{ env.AWS_REGION }}" || echo "âš ï¸  Terraform destroy reported errors (continuing with cleanup)"
        echo "âœ… Terraform destroy command finished"

    - name: Force cleanup AWS resources
      run: |
        set -euo pipefail
        echo "ðŸ§¹ Forcing cleanup of orphaned AWS resources"

        echo "Cleaning IAM roles..."
        aws iam detach-role-policy --role-name data-viewer-dashboard-apprunner-access-role --policy-arn arn:aws:iam::aws:policy/service-role/AWSAppRunnerServicePolicyForECRAccess 2>/dev/null || true
        aws iam delete-role-policy --role-name data-viewer-dashboard-apprunner-instance-role --policy-name data-viewer-dashboard-apprunner-instance-policy 2>/dev/null || true
        aws iam delete-role --role-name data-viewer-dashboard-apprunner-instance-role 2>/dev/null || true
        aws iam delete-role --role-name data-viewer-dashboard-apprunner-access-role 2>/dev/null || true

        echo "Cleaning ECR repository..."
        aws ecr delete-repository --repository-name $ECR_REPOSITORY --force 2>/dev/null || true

        echo "Cleaning App Runner services..."
        SERVICE_ARNS=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='data-viewer-dashboard'].ServiceArn" --output text 2>/dev/null || echo "")
        if [ -n "$SERVICE_ARNS" ]; then
          for ARN in $SERVICE_ARNS; do
            echo "  Deleting service: $ARN"
            aws apprunner delete-service --service-arn "$ARN" 2>/dev/null || true
          done
        fi

        echo "Cleanup complete"

    - name: Ensure ECR repository exists
      run: |
        set -euo pipefail
        cd dashboard/deploy/terraform
        terraform apply -auto-approve -target=aws_ecr_repository.app_repository -var="aws_region=${{ env.AWS_REGION }}"

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Create GCP credentials file
      run: |
        set -euo pipefail
        mkdir -p .tmp
        echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > .tmp/service-client.json
        if [ ! -f .tmp/service-client.json ]; then
          echo "âŒ Failed to create credentials file"
          exit 1
        fi

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
        DEPLOY_BRANCH: ${{ env.DEPLOY_BRANCH }}
      run: |
        set -euo pipefail
        docker buildx build \
          --no-cache \
          --progress=plain \
          --load \
          --platform linux/amd64 \
          -f dashboard/deploy/Dockerfile \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_BRANCH \
          .

        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_BRANCH
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Cleanup credentials
      if: always()
      run: |
        rm -rf .tmp/service-client.json .tmp/

    - name: Verify ECR image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
        DEPLOY_BRANCH: ${{ env.DEPLOY_BRANCH }}
      run: |
        set -euo pipefail
        aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG
        aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$DEPLOY_BRANCH
        aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=latest

    - name: Terraform Plan
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      run: |
        set -euo pipefail
        cd dashboard/deploy/terraform
        terraform plan -var="aws_region=${{ env.AWS_REGION }}"

    - name: Terraform Apply
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      run: |
        set -euo pipefail
        cd dashboard/deploy/terraform
        echo "ðŸ”¨ Creating fresh infrastructure..."
        terraform apply -auto-approve -var="aws_region=${{ env.AWS_REGION }}"

    - name: Deploy to App Runner
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
        DEPLOY_BRANCH: ${{ env.DEPLOY_BRANCH }}
      run: |
        set -euo pipefail
        SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='$ECR_REPOSITORY'].ServiceArn" --output text)
        if [ -z "$SERVICE_ARN" ]; then
          echo "âŒ App Runner service was not created. Check Terraform logs."
          exit 1
        fi

        aws apprunner start-deployment --service-arn "$SERVICE_ARN"
        aws apprunner wait service-updated --service-arn "$SERVICE_ARN"
        SERVICE_URL=$(aws apprunner describe-service --service-arn $SERVICE_ARN --query "Service.ServiceUrl" --output text)
        echo "âœ… Service deployed successfully!"
        echo "ðŸŒ Service URL: https://$SERVICE_URL"

    - name: Output deployment info
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
        DEPLOY_BRANCH: ${{ env.DEPLOY_BRANCH }}
      run: |
        echo "Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "Branch tag:  $ECR_REGISTRY/$ECR_REPOSITORY:$DEPLOY_BRANCH"
        echo "Latest tag:  $ECR_REGISTRY/$ECR_REPOSITORY:latest"
        SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='$ECR_REPOSITORY'].ServiceArn" --output text)
        if [ -n "$SERVICE_ARN" ]; then
          SERVICE_URL=$(aws apprunner describe-service --service-arn $SERVICE_ARN --query "Service.ServiceUrl" --output text 2>/dev/null || echo "")
          if [ -n "$SERVICE_URL" ]; then
            echo "Dashboard URL: https://$SERVICE_URL"
          fi
        fi
